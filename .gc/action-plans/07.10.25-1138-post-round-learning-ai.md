### Overall Goal
Implement dynamic AI learning within a single match:
1. After every round the backend calls OpenAI once more to analyse that round’s conversation and return:
   • `analysis` – patterns/strategies players used (string)
   • `comment`  – a boast / humility sentence depending on the winner (string, ignored for now)
2. Store each `analysis` in-memory for the lifetime of the match so subsequent AI guesses can reference accumulated player behaviour.
3. Keep code changes confined to backend; no immediate frontend work required.

### Regression-Risk Analysis & Mitigations
| Risk | Impact | Mitigation |
|------|--------|-----------|
| Prompt size grows with many rounds → slightly higher token cost | Low | Monitor; each entry is short so risk acceptable |
| New optional field in `GameState` accidentally `undefined` where used | Low | Initialise array in `createGameState`; add `!` non-null assertions only after null-check |
| Break existing tests relying on strict `GameState` typing | Medium | Update types & adjust failing tests; run `npm test` before commit |
| Two extra OpenAI calls could hit rate-limit | Low | Re-use existing back-off logic; throttle with 200 ms delay between calls | 
| Unused `comment` string triggers linter warnings | Low | Prefix assignment with `_` or simply omit variable | 

### Action Steps
1. **Extend backend types**  
   • File: `backend/src/types/index.ts`  
   • Inside the `GameState` interface (right after `conversationHistory` is a convenient spot) add:  
     ```ts
     /** Accumulated one-sentence pattern notes from previous rounds */
     previousRoundsAnalysis?: string[];
     ```

2. **Seed new property at game creation**  
   • File: `backend/src/game/state.ts`  
   • In `createGameState`, add:  
     ```ts
     previousRoundsAnalysis: [],
     ```

3. **Add OpenAI helper to analyse a finished round**  
   • File: `backend/openai/services/openai.ts`  
   • Create `async analyzeRoundStrategy(summary: RoundSummary)`
   • This function is separate from `analyzeConversation` (keeps concerns clear), but **`analyzeConversation` will later receive `previousRoundsAnalysis` as an extra parameter** so it can prepend those insights to its own prompt.

4. **Define `RoundSummary` type**  
   • File: `backend/openai/types/game.ts` (or new `round.ts`)  
   • Structure:  
     ```ts
     export interface RoundSummary {
       winner: 'players' | 'ai';
       secretWord: string;
       conversation: Turn[];
       round: number;
     }
     ```

5. **Invoke new helper at round end**  
   • File: `backend/src/socket/handlers/gameHandlers.ts`  
   • In both round-winning branches (`handlePlayerGuess`, `handleAIResponse`):  
     ```ts
     const summary: RoundSummary = { winner, secretWord: room.gameState.secretWord, conversation: room.gameState.conversationHistory, round: room.gameState.currentRound };
     const { analysis /*, comment*/ } = await aiService.analyzeRoundStrategy(summary);
     room.gameState.previousRoundsAnalysis!.push(analysis);
     ```
   • Discard `comment` for now.

6. **Feed accumulated analysis into future prompts**  
   • File: `backend/openai/services/openai.ts`  
   • Update `analyzeConversation(turns, previousAnalyses)` to accept an optional string array and prepend one sentence when array length > 0.
   • From `handleAIResponse`, pass `room.gameState.previousRoundsAnalysis`.

7. **House-keeping**  
   • Update or add unit tests:  
     – Ensure `previousRoundsAnalysis` initialises empty.  
     – Ensure it grows by 1 after a simulated round end.  
   • Run full test suite (`npm test`) to catch regressions.

8. **Optional (future)**  
   • When ready to show taunt line, either emit `comment` via `round_end` payload or add `lastRoundComment` to `GameState`. 